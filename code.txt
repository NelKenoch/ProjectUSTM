# SMARTLEARN USTM - Syst√®me expert complet avec auto-enrichissement
!pip install -q transformers torch faiss-gpu gradio PyPDF2 sentence-transformers spacy
!python -m spacy download fr_core_news_sm

import json
import numpy as np
import faiss
import spacy
from sentence_transformers import SentenceTransformer
from transformers import pipeline, AutoModelForSeq2SeqLM, AutoTokenizer
import gradio as gr
from datetime import datetime

# 1. Initialisation des mod√®les
class KnowledgeSystem:
    def __init__(self):
        print("Chargement des mod√®les...")
        # Mod√®le de base
        self.embedder = SentenceTransformer('all-mpnet-base-v2')
        self.generator = pipeline("text-generation", model="gpt2")
        
        # Mod√®les pour l'extension automatique
        self.nlp = spacy.load("fr_core_news_sm")
        self.summarizer = pipeline("summarization", model="plguillou/t5-base-fr-sum-cnndm")
        
        # Base de connaissances
        self.knowledge_base = {}
        self.knowledge_keys = []
        self.index = faiss.IndexFlatL2(768)
        self._load_knowledge()
    
    # 2. Fonctions de base
    def _load_knowledge(self):
        """Charge la base depuis le fichier JSON"""
        try:
            with open("knowledge_base.json", "r") as f:
                self.knowledge_base = json.load(f)
                self._rebuild_index()
            print(f"Base charg√©e avec {len(self.knowledge_base)} entr√©es")
        except FileNotFoundError:
            self.knowledge_base = {
                "lois_de_newton": {
                    "description": "Les trois lois de Newton",
                    "contenu": "1. Loi d'inertie\n2. F=ma\n3. Action-r√©action",
                    "metadata": {
                        "source": "manuel_physique_USTM",
                        "date_ajout": "2023-01-15"
                    }
                }
            }
            self._save_knowledge()
    
    def _rebuild_index(self):
        """Reconstruit l'index FAISS"""
        self.knowledge_keys = list(self.knowledge_base.keys())
        embeddings = []
        for key in self.knowledge_keys:
            text = f"{self.knowledge_base[key]['description']} {self.knowledge_base[key]['contenu']}"
            embeddings.append(self.embedder.encode(text))
        if embeddings:
            self.index.add(np.array(embeddings))
    
    def _save_knowledge(self):
        """Sauvegarde la base dans un fichier JSON"""
        with open("knowledge_base.json", "w") as f:
            json.dump(self.knowledge_base, f, indent=2)
    
    # 3. Fonctions principales
    def generate_qcm(self, topic):
        """G√©n√®re un QCM contextualis√©"""
        context = self._get_context(topic)
        prompt = f"""G√©n√®re 3 QCM universitaires sur: {topic}
Contexte:
{context}

Format:
Question 1: [√©nonc√© clair et pr√©cis]
a) Option plausible
b) Option incorrecte
c) Option pertinente
d) Option sp√©cifique
R√©ponse: [lettre]

QCM:"""
        response = self.generator(prompt, max_length=600, temperature=0.6)
        return response[0]['generated_text']
    
    def _get_context(self, query, k=3):
        """R√©cup√®re les connaissances pertinentes"""
        query_embed = self.embedder.encode(query)
        distances, indices = self.index.search(np.array([query_embed]), k)
        
        context = []
        for i in indices[0]:
            if i >= 0:
                key = self.knowledge_keys[i]
                context.append(f"### {self.knowledge_base[key]['description']}\n{self.knowledge_base[key]['contenu']}")
        return "\n\n".join(context)
    
    # 4. Fonctions d'extension (Nouvelles)
    def auto_extract_concepts(self, text, source_name):
        """Extrait automatiquement des concepts d'un texte"""
        doc = self.nlp(text)
        concepts = []
        
        # Extraction des phrases importantes
        sentences = [sent.text for sent in doc.sents]
        important_sents = self.summarizer(
            " ".join(sentences),
            max_length=150,
            min_length=30,
            do_sample=False
        )[0]['summary_text']
        
        # Extraction des entit√©s nomm√©es
        entities = [(ent.text, ent.label_) for ent in doc.ents]
        
        # Cr√©ation des nouvelles entr√©es
        today = datetime.now().strftime("%Y-%m-%d")
        for i, sent in enumerate(important_sents.split(". ")):
            if len(sent) > 20:
                concept_id = f"{source_name}_concept_{i}"
                self.knowledge_base[concept_id] = {
                    "description": f"Concept extrait de {source_name}",
                    "contenu": sent,
                    "metadata": {
                        "source": source_name,
                        "date_ajout": today,
                        "type": "auto-extracted"
                    }
                }
                concepts.append(concept_id)
        
        if concepts:
            self._rebuild_index()
            self._save_knowledge()
        return concepts
    
    def process_pdf(self, file_bytes, source_name):
        """Traite un PDF et extrait les connaissances"""
        from PyPDF2 import PdfReader
        import io
        
        text = ""
        try:
            reader = PdfReader(io.BytesIO(file_bytes))
            for page in reader.pages[:5]:  # Limite √† 5 pages
                text += page.extract_text() or ""
            return self.auto_extract_concepts(text[:5000], source_name)
        except Exception as e:
            return f"Erreur: {str(e)}"
    
    def validate_content(self, concept_id, user_feedback):
        """Valide ou corrige une entr√©e"""
        if concept_id in self.knowledge_base:
            self.knowledge_base[concept_id]["metadata"]["feedback"] = user_feedback
            if "incorrect" in user_feedback.lower():
                self.knowledge_base[concept_id]["metadata"]["status"] = "√†_reviser"
            self._save_knowledge()
            return "Merci pour votre feedback!"
        return "Concept introuvable"

# 5. Interface compl√®te
system = KnowledgeSystem()

with gr.Blocks(title="SmartLearn USTM - Syst√®me Expert") as app:
    gr.Markdown("# üß† SmartLearn USTM - Plateforme P√©dagogique Intelligente")
    
    with gr.Tabs():
        with gr.Tab("G√©n√©ration de QCM"):
            gr.Markdown("## G√©n√©rer des QCM bas√©s sur les connaissances")
            topic_input = gr.Textbox(label="Sujet ou concept")
            generate_btn = gr.Button("G√©n√©rer QCM")
            qcm_output = gr.Textbox(label="R√©sultat", interactive=True)
        
        with gr.Tab("Enrichissement Automatique"):
            gr.Markdown("## Ajouter des connaissances depuis des documents")
            with gr.Row():
                doc_input = gr.File(label="Document PDF")
                source_input = gr.Textbox(label="Source (ex: 'Cours_Physique_L1')")
            auto_extract_btn = gr.Button("Extraire les concepts")
            concepts_output = gr.JSON(label="Concepts extraits")
        
        with gr.Tab("Validation Collaborative"):
            gr.Markdown("## Am√©liorer la qualit√© des connaissances")
            concept_select = gr.Dropdown(
                choices=list(system.knowledge_base.keys()),
                label="S√©lectionner un concept"
            )
            feedback_input = gr.Textbox(label="Votre feedback")
            validate_btn = gr.Button("Soumettre")
            validation_output = gr.Textbox(label="Statut")

    # Liaisons des fonctions
    generate_btn.click(
        fn=system.generate_qcm,
        inputs=topic_input,
        outputs=qcm_output
    )
    
    auto_extract_btn.click(
        fn=system.process_pdf,
        inputs=[doc_input, source_input],
        outputs=concepts_output
    )
    
    validate_btn.click(
        fn=system.validate_content,
        inputs=[concept_select, feedback_input],
        outputs=validation_output
    )

# Lancement
print("Pr√™t! Acc√©dez √† l'interface via le lien Gradio")
app.launch(share=True, debug=True)
